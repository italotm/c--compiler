import java_cup.runtime.*;
import classes.Verificador;
import classes.BlocoPrincipal;
import classes.Variavel;
import classes.Funcao;
import java.util.ArrayList;

/*Este codigo foi reusado. Ele serve para nos mostrar aonde ocorreu um erro, ao ler um arquivo de entrada.*/
parser code {:
    
    public void report_error(String message, Object info) {
   
        StringBuffer m = new StringBuffer("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            
            if (s.left >= 0) {
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(" in line "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0)                    
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", column "+(s.right+1));
            }
        }
   
	
        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

/*Aqui estao listado todos os simbolos terminais da nossa gramatica*/
terminal LPAREN, RPAREN, MENOS, MAIS, BARRA, ASTERISCO, ABSTRACT, AS, BASE, 
BOOL, BREAK, BYTE, CASE, CATCH, CHAR, CHECKED, CLASS, CONST, CONTINUE, DECIMAL,
 DEFAULT, DELEGATE, DO, DOUBLE, ELSE, ENUM, EVENT, EXPLICIT, EXTERN, FALSE, FINALLY, FIXED, FLOAT, FOR, 
 FOREACH, GOTO, IF, IMPLICIT, IN, INT, INTERFACE, INTERNAL, IS, LOCK, LONG, NAMESPACE, NEW, NULL, OBJECT, 
 OPERATOR, OUT, OVERRIDE, PARAMS, PRIVATE, PROTECTED, PUBLIC, READONLY, REF, RETURN, SBYTE, SEALED,
 SHORT, SIZEOF, STACKALLOC, STATIC, STRING, STRUCT, SWITCH, THIS, THROW, TRUE, TRY, TYPEOF, UINT, 
 ULONG, UNCHECKED, UNSAFE, USHORT, USING, VIRTUAL, VOID, VOLATILE, WHILE, BOOLEAN, LETRA, LCHAVE, RCHAVE, LCOLCHETE, RCOLCHETE,
 PONTO, VIRGULA, DOISPONTOS,PONTOEVIRGULA,PERCENT, ECOMERCIAL,PIPE,CIRCUNFLEXO,EXCLAMACAO,TIO,IGUAL,MENOR,MAIOR,INTERROGACAO,INCREMENTO,
 DECREMENTO,ECOMERCIALDUPLO,ORPIPE, MENORMENOR,MAIORMAIOR,IGUALIGUAL,DIFERENTE,MENORIGUAL,MAIORIGUAL,MAISIGUAL,MENOSIGUAL,VEZESIGUAL,DIVIDEIGUAL,
 PERCENTIGUAL, ECOMERCIALIGUAL, PIPEIGUAL, TIOIGUAL, MENORMENORIGUAL,MAIORMAIORIGUAL,PONTEIRO, IDENT, DEFINE, UNDEF, CERQUILHA, WHITESPACE, INTEGERTYPESUFFIX,
 INTEGERLITERAL, IDENTARROBA, CHARLITERAL, ASSEMBLY, REALLITERAL, STRINGLITERAL, FIELD, METHOD, MODULE, PARAM, PROPERTY, TYPE, GET, SET, ADD, REMOVE;

/*Aqui estao todos os simbolos nao terminais da gramatica*/
non terminal compilation_unit, identifier, qualified_identifier, using_directive, global_attributes, global_attribute_section, attribute_list ,attribute, atribute_name, attribute_arguments ,expression_list, expression_equality_operator, expression_relational_operator, expression_shift_operator, assignment_operator, expression_unary_operator, unary_expression,virgula_recursion_aux ,virgula_optional ,rank_specifier, rank_specifier_optional, rank_specifier_recursion_optional, variable_initializer, variable_initializer_recursion, array_initializer, array_initializer_optional, integral_type, ral, integer_literal, real_literal, character_literal, string_literal, null_literal, literal, predefined_type, argument_list,argument_recursion_optional, argument, ref_or_out, increment_decrement, type, type_or_void, primary_expression, expression, built_in_class_type, built_in_type, non_array_type, array_type, boolean_literal,
namespace_member_declaration_aux, namespace_member_declaration, namespace_declaration, namespace_body, using_directive_aux,
attributes, attribute_section_aux, attribute_section, attribute_target_aux, attribute_target,
enum_declaration, enum_modifier_aux, integral_type_aux, enum_body, enum_modifier, enum_member_declaration_aux, enum_member_declaration,
shift_reduce_global_atributes_namespace_member, using_directive_recursion, global_attribute_section_aux,
type_declaration, delegate_declaration, delegate_modifier, delegate_modifier_aux, formal_parameter_list,
fixed_parameters, fixed_parameter_aux, fixed_parameter, parameter_modifier, parameter_array, formal_parameter_list_aux,
interface_declaration, interface_modifier, qualified_indetifier_list, qualified_indetifier_list_aux,
ponto_virgula_opt, interface_body, interface_member_declaration_aux, interface_member_declaration,
interface_method_declaration, new_opt, interface_property_declaration, interface_accessors, interface_event_declaration, interface_indexer_declaration,
struct_declaration, struct_modifier, qualified_identifier_list_aux, qualified_identifier_list, struct_body,
struct_member_declaration_aux, struct_member_declaration, constant_declaration, constant_modifier, field_declaration,
field_modifier, variable_declarator_aux, variable_declarator, method_declaration, method_header, method_modifier,
maybe_empty_block, statement_aux, statement, labeled_statement, declaration_statement, local_variable_declaration,
local_constant_declaration, constant_declarator_aux, constant_declarator, embedded_statement, statement_expression,
selection_statement, if_statement, else_part_opt, else_part, switch_statement, switch_section_aux, switch_section,
statement_mais, switch_label_aux, switch_label, iteration_statement, while_statement, do_statement, for_statement,
for_initializer, expression_opt, statement_expression_list_opt, statement_expression_list, foreach_statement,
jump_statement, break_statement, continue_statement, goto_statement, return_statement, throw_statement,
try_statement, catch_clauses, finally_clause, finally_clause_opt, block, specific_catch_clause_mais, specific_catch_clause,
general_catch_clause_opt, general_catch_clause, specific_catch_clause_aux, identifier_opt, lock_statement,
using_statement, resource_acquisition, property_declaration, property_modifier, accessor_declarations, set_accessor_declaration_opt,
get_accessor_declaration_opt, get_accessor_declaration, set_accessor_declaration, event_declaration, event_modifier,
event_accessor_declarations, add_accessor_declaration, remove_accessor_declaration, class_declaration, class_base_opt,
class_modifier, class_base, qualified_identifier_list_opt, class_body, class_member_declaration_aux, class_member_declaration,
general_modifier, general_init, general_init_met_prop, modifier, constructor_declaration, constructor_declarator,
constructor_initializer_opt, constructor_initializer;

/*Aqui estao as regras de producao*/

start with compilation_unit;

compilation_unit ::= using_directive_recursion shift_reduce_global_atributes_namespace_member;
shift_reduce_global_atributes_namespace_member ::= global_attributes namespace_member_declaration_aux | global_attributes | namespace_member_declaration_aux;
using_directive_recursion ::= | using_directive | using_directive using_directive_recursion;
identifier ::= IDENT:id {: RESULT = id.toString(); :} | IDENTARROBA;
qualified_identifier ::= identifier:i {: RESULT = i; :} | identifier PONTO qualified_identifier;
using_directive ::= | USING qualified_identifier PONTOEVIRGULA | USING identifier IGUAL qualified_identifier PONTOEVIRGULA;    

/*NAMESPACE*/
namespace_member_declaration_aux ::= | namespace_member_declaration | namespace_member_declaration namespace_member_declaration_aux;
namespace_member_declaration ::= namespace_declaration | type_declaration;
namespace_declaration ::=  NAMESPACE qualified_identifier namespace_body ponto_virgula_opt;
namespace_body ::= LCHAVE using_directive namespace_member_declaration_aux RCHAVE;

type_declaration ::= class_declaration | struct_declaration | interface_declaration | enum_declaration | delegate_declaration;
/* GLOBAL ATRIBUTES*/

global_attributes::= global_attribute_section_aux;
global_attribute_section_aux ::= | global_attribute_section | global_attribute_section global_attribute_section_aux;
global_attribute_section::= LCOLCHETE ASSEMBLY DOISPONTOS attribute_list RCOLCHETE;
attribute_list ::= attribute | attribute VIRGULA attribute_list;
attribute ::= atribute_name |atribute_name attribute_arguments;
atribute_name ::= qualified_identifier;
attribute_arguments ::= LPAREN RPAREN | LPAREN expression_list RPAREN;
expression_list ::= expression | expression VIRGULA expression_list;

expression_equality_operator::= IGUALIGUAL:ii {: RESULT = ii; :} | DIFERENTE:di {: RESULT = di; :};

expression_relational_operator::= MENOR:me {: RESULT = me; :} | MAIOR:ma {: RESULT = ma; :} | MENORIGUAL:mei {: RESULT = mei; :} | MAIORIGUAL:mai {: RESULT = mai; :} | IS:is {: RESULT = is; :} | AS:as {: RESULT = as; :};

expression_shift_operator::= MENORMENOR | MAIORMAIOR;

assignment_operator::= IGUAL:ig {: RESULT = ig; :} | MAISIGUAL:ma {: RESULT = ma; :} | MENOSIGUAL:me {: RESULT = me; :} | VEZESIGUAL:ve {: RESULT = ve; :} | DIVIDEIGUAL:di {: RESULT = di; :} | PERCENTIGUAL:pe {: RESULT = pe; :} | ECOMERCIALIGUAL:ec {: RESULT = ec; :} | PIPEIGUAL:pi {: RESULT = pi; :} | TIOIGUAL:ti {: RESULT = ti; :} | MENORMENORIGUAL:me {: RESULT = me; :} | MAIORMAIORIGUAL:ma {: RESULT = ma; :};

expression_unary_operator ::= MAIS | MENOS | DECREMENTO | INCREMENTO | EXCLAMACAO | TIO | ASTERISCO;
    
unary_expression::= expression_unary_operator unary_expression | LPAREN type RPAREN unary_expression | primary_expression:pe {: RESULT = pe; :};

virgula_recursion_aux ::= | VIRGULA | VIRGULA virgula_recursion_aux;
virgula_optional ::= | VIRGULA; 
rank_specifier ::= LCOLCHETE virgula_recursion_aux RCOLCHETE;
rank_specifier_optional ::= | rank_specifier;
rank_specifier_recursion_optional ::= | rank_specifier | rank_specifier rank_specifier_recursion_optional;

variable_initializer ::= expression:e {: RESULT = e; :} | array_initializer;
variable_initializer_recursion ::= variable_initializer | variable_initializer VIRGULA variable_initializer_recursion; 
array_initializer::= LCHAVE RCHAVE | LCHAVE variable_initializer_recursion virgula_optional RCHAVE;
array_initializer_optional ::= | array_initializer;

integral_type ::= SBYTE {: RESULT = new String("sby"); :} | BYTE {: RESULT = new String("by"); :} |SHORT {: RESULT = new String("sh"); :} | USHORT {: RESULT = new String("us"); :} |INT {: RESULT = new String("il"); :} |UINT {: RESULT = new String("ui"); :} |LONG {: RESULT = new String("il"); :} |ULONG {: RESULT = new String("il"); :} | CHAR {: RESULT = new String("ch"); :};

built_in_class_type ::= OBJECT {: RESULT = new String("ob"); :} | STRING {: RESULT = new String("st"); :};

built_in_type::= integral_type:it {: RESULT = it; :} | built_in_class_type:bict {: RESULT = bict; :} | BOOL {: RESULT = new String("bo"); :} | DECIMAL {: RESULT = new String("de"); :} | FLOAT {: RESULT = new String("fl"); :} | DOUBLE {: RESULT = new String("do"); :};

non_array_type::= qualified_identifier:qi {: RESULT = qi; :} | built_in_type:bit {: RESULT = bit; :}; 

array_type ::= non_array_type | rank_specifier_optional;

boolean_literal ::= TRUE | FALSE;
integer_literal ::= INTEGERLITERAL:i {: RESULT = i; :};
real_literal ::=  REALLITERAL;
character_literal ::=  CHARLITERAL;
string_literal ::=  STRINGLITERAL;
null_literal ::= NULL;
literal::= boolean_literal {: RESULT = new String("bo"); :} | integer_literal:il {: RESULT = (new String("il")); :} | real_literal  {: RESULT = new String("re"); :}| character_literal {: RESULT = new String("ch"); :} |string_literal {: RESULT = new String("st"); :} | null_literal {: RESULT = new String("null"); :};
predefined_type ::= BOOL |BYTE |CHAR |DECIMAL |DOUBLE | FLOAT | INT | LONG | OBJECT | SBYTE | SHORT | STRING | UINT | ULONG |USHORT;

argument_list::= argument_recursion_optional;
argument_recursion_optional ::= | argument | argument VIRGULA argument_recursion_optional;
argument::= identifier:i {: if (i != null){ Verificador.addParametro(new Variavel(i.toString(), null, "variavel"));} :} | expression:e {: if (e != null){ Verificador.addParametro(new Variavel(e.toString(), null, "variavel"));} :} | ref_or_out expression; 

ref_or_out::= REF | OUT;
increment_decrement ::= INCREMENTO | DECREMENTO;
type ::= non_array_type:nat {: RESULT = nat; :} rank_specifier_recursion_optional;

type_or_void::= type:t {: RESULT = t; :} | VOID {: RESULT = new String("vo"); :};

primary_expression ::= 
    NEW non_array_type LCOLCHETE expression_list RCOLCHETE rank_specifier_recursion_optional array_initializer_optional |
    NEW array_type array_initializer |
    literal:l {: RESULT = l; :}|
    identifier:i {: RESULT = i; :}|
    identifier PONTO identifier|
    LPAREN expression RPAREN |
    primary_expression PONTO identifier |
    predefined_type PONTO identifier |
    qualified_identifier:qi LPAREN:l {: Verificador.linha = ((int) l)+1; RESULT = qi; :} argument_list RPAREN |
    primary_expression LCOLCHETE expression_list RCOLCHETE |
    THIS |
    BASE PONTO identifier |
    BASE LCOLCHETE expression_list RCOLCHETE |
    primary_expression increment_decrement |
    NEW type:t {: RESULT = t; :} LPAREN argument_list RPAREN |
    TYPEOF LPAREN type_or_void RPAREN |
    CHECKED LPAREN expression RPAREN |
    UNCHECKED LPAREN expression RPAREN;




expression ::= 
	identifier:i {: RESULT = i;  :} |
 	expression INTERROGACAO expression DOISPONTOS expression |
    expression ORPIPE expression {: RESULT = new String("bo"); :} | 
    expression ECOMERCIALDUPLO expression {: RESULT = new String("bo"); :} |
    expression CIRCUNFLEXO expression  {: RESULT = new String("ns"); :} |
    expression:e IS:is built_in_type:bit {: if (e != null){ Verificador.verificarVariavel(e.toString(), ((int) is)+1); } RESULT = new String("bo"); :} |
    expression ASTERISCO expression {: RESULT = new String("ns"); :} |
    expression BARRA expression {: RESULT = new String("ns"); :} |
    expression PERCENT expression {: RESULT = new String("ns"); :} |  
    expression PIPE expression {: RESULT = new String("ns"); :} |
    expression ECOMERCIAL expression {: RESULT = new String("ns"); :} |
    expression:e1 expression_equality_operator:eeo expression:e2 {: if (e1 != null && e2 != null ){ Verificador.verificarIgualdade(e1.toString(), e2.toString(), ((int) eeo)+1); } RESULT = new String("bo"); :} |
    expression:e1 expression_relational_operator:ero expression:e2 {: if (e1 != null && e2 != null ){ Verificador.verificarRelacao(e1.toString(), e2.toString(), ((int) ero)+1); } RESULT = new String("bo"); :} |
    expression expression_shift_operator expression {: RESULT = new String("ns"); :} |
    expression MAIS expression {: RESULT = new String("ns"); :} |
    expression MENOS expression {: RESULT = new String("ns"); :} |
    unary_expression:ue {: RESULT = ue; :} |
    unary_expression assignment_operator expression ;

/*enum*/
enum_declaration ::= attributes enum_modifier_aux ENUM identifier integral_type_aux enum_body PONTOEVIRGULA |
					attributes enum_modifier_aux ENUM identifier integral_type_aux enum_body;
enum_modifier_aux ::= | enum_modifier | enum_modifier enum_modifier_aux;
enum_modifier ::= NEW|PUBLIC|PROTECTED|INTERNAL|PRIVATE;
integral_type_aux ::= | DOISPONTOS integral_type;
enum_body ::= LCHAVE RCHAVE | LCHAVE enum_member_declaration_aux RCHAVE;
enum_member_declaration_aux ::=  enum_member_declaration | enum_member_declaration VIRGULA enum_member_declaration_aux;
enum_member_declaration ::= attributes identifier IGUAL expression | attributes identifier;

/*ATTRIBUTES*/
attributes ::= attribute_section_aux;
attribute_section_aux ::= | attribute_section | attribute_section attribute_section_aux;
attribute_section ::= LCOLCHETE attribute_target_aux attribute_list RCOLCHETE;
attribute_target_aux ::= | attribute_target DOISPONTOS;
attribute_target ::= FIELD|EVENT|METHOD|MODULE|PARAM|PROPERTY|RETURN|TYPE;

/*delegate*/
delegate_declaration ::= attributes delegate_modifier_aux DELEGATE type_or_void identifier LPAREN formal_parameter_list_aux RPAREN PONTOEVIRGULA;
delegate_modifier_aux ::= | delegate_modifier | delegate_modifier delegate_modifier_aux;
delegate_modifier ::= NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE;

formal_parameter_list_aux ::= | formal_parameter_list;
formal_parameter_list ::= fixed_parameters | parameter_array;
fixed_parameters ::= fixed_parameter_aux;
fixed_parameter_aux ::= fixed_parameter  | fixed_parameter VIRGULA fixed_parameter_aux;
fixed_parameter ::= attributes parameter_modifier type:t identifier:i {: if (i != null && t != null) Verificador.addParametro(new Variavel(i.toString(), t.toString(), "variavel")); :};
parameter_modifier ::= | REF | OUT;
parameter_array ::= attributes PARAMS array_type identifier;

/*interface*/
interface_declaration ::= attributes interface_modifier INTERFACE identifier qualified_indetifier_list_aux;
interface_modifier ::= | NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE;

qualified_indetifier_list_aux ::= | DOISPONTOS qualified_indetifier_list interface_body ponto_virgula_opt;
qualified_indetifier_list ::= qualified_identifier | qualified_identifier VIRGULA qualified_indetifier_list;
ponto_virgula_opt ::= | PONTOEVIRGULA;

interface_body ::= LCHAVE interface_member_declaration_aux RCHAVE;
interface_member_declaration_aux ::= | interface_member_declaration interface_member_declaration_aux;
interface_member_declaration ::= interface_method_declaration | interface_property_declaration | interface_event_declaration | interface_indexer_declaration;

interface_method_declaration ::= attributes new_opt type_or_void identifier LPAREN formal_parameter_list_aux RPAREN PONTOEVIRGULA;
new_opt ::= | NEW;

interface_property_declaration ::= attributes new_opt type identifier LCHAVE interface_accessors RCHAVE; 
interface_accessors ::= attributes GET PONTOEVIRGULA | attributes GET PONTOEVIRGULA attributes SET PONTOEVIRGULA | attributes SET PONTOEVIRGULA | attributes SET PONTOEVIRGULA attributes GET PONTOEVIRGULA;

interface_event_declaration ::= attributes new_opt EVENT type identifier PONTOEVIRGULA;

interface_indexer_declaration ::= attributes new_opt type THIS LCOLCHETE formal_parameter_list RCOLCHETE LCHAVE interface_accessors RCHAVE;

/*struct*/
struct_declaration ::= attributes struct_modifier STRUCT identifier qualified_identifier_list_aux struct_body ponto_virgula_opt;
struct_modifier ::= | NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE;
qualified_identifier_list_aux ::= | DOISPONTOS qualified_identifier_list;
qualified_identifier_list ::= qualified_identifier:qi {: RESULT = qi; :} | qualified_identifier VIRGULA qualified_identifier_list;
struct_body ::= LCHAVE struct_member_declaration_aux RCHAVE;
struct_member_declaration_aux ::= | struct_member_declaration struct_member_declaration_aux;

struct_member_declaration ::= constant_declaration | field_declaration | method_declaration | property_declaration | event_declaration;
constant_declaration ::= general_modifier CONST type constant_declarator_aux PONTOEVIRGULA;
constant_modifier ::= | NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE;
field_declaration ::= general_init:gi variable_declarator_aux:vd PONTOEVIRGULA:pv {: Verificador.linha = ((int) pv)+1; if (vd != null && gi != null) { Verificador.verificaTipo(gi.toString(), (Variavel) vd);} :};
field_modifier ::= | NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | READONLY | VOLATILE;
variable_declarator_aux ::= variable_declarator:vd {: RESULT = vd; :} | variable_declarator variable_declarator_aux;
variable_declarator ::= identifier:i {: RESULT = new Variavel(i.toString(), null, "variavel"); :} | identifier:i IGUAL variable_initializer:vi {: RESULT = new Variavel(i.toString(), vi.toString(), "variavel"); :};


method_declaration ::= method_header:mh {: if (mh != null) { Verificador.addFuncao((new Funcao(((Variavel) mh).getNome(), ((Variavel) mh).getTipo(), new ArrayList<Variavel>(), "funcao"))); BlocoPrincipal.getInstance().iniciaBloco(((Variavel) mh).getNome()); } :} maybe_empty_block {: BlocoPrincipal.getInstance().finalizaBloco(); :};
method_header ::= general_init_met_prop:gimp LPAREN:l {: Verificador.linha = ((int) l)+1; RESULT = gimp; :} formal_parameter_list_aux:fpla {: if (fpla != null) { Verificador.addParametro((Variavel) fpla); } :} RPAREN;
method_modifier ::= | NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN;
maybe_empty_block ::= LCHAVE statement_aux RCHAVE | PONTOEVIRGULA;
statement_aux ::= | statement statement_aux;
statement ::= labeled_statement | declaration_statement | embedded_statement;
labeled_statement ::= identifier DOISPONTOS statement;
declaration_statement ::=  local_variable_declaration PONTOEVIRGULA:pv {: Verificador.linha = ((int) pv)+1; :} |  local_constant_declaration PONTOEVIRGULA;
local_variable_declaration ::= type:t variable_declarator_aux:vd {: if (vd != null && t != null) { Verificador.verificaTipo(t.toString(), (Variavel) vd);} :};
local_constant_declaration ::= CONST type constant_declarator_aux;
constant_declarator_aux ::= constant_declarator | constant_declarator constant_declarator_aux;
constant_declarator ::= identifier IGUAL expression;
embedded_statement ::= maybe_empty_block | statement_expression PONTOEVIRGULA | selection_statement | iteration_statement | jump_statement | try_statement | CHECKED block | UNCHECKED block | lock_statement | using_statement;
statement_expression ::=  primary_expression:pe {: if (pe != null) { Verificador.verificarMetodo(pe.toString()); } :} | NEW type LPAREN argument_list RPAREN | unary_expression:ue assignment_operator:ao expression:e {: if (ue != null && e != null){ Verificador.verificaAtribuicao(ue.toString(), e.toString(), ((int) ao)+1); } :} | primary_expression increment_decrement | increment_decrement primary_expression;
selection_statement ::= if_statement | switch_statement;
if_statement ::= IF LPAREN expression RPAREN embedded_statement else_part_opt;
else_part_opt ::= | else_part;
else_part ::= ELSE embedded_statement;
switch_statement ::= SWITCH LPAREN expression RPAREN LCHAVE switch_section_aux RCHAVE;
switch_section_aux ::= | switch_section switch_section_aux;
switch_section ::= switch_label_aux statement_mais;
switch_label_aux ::= switch_label | switch_label switch_label_aux;
statement_mais ::= statement | statement statement_mais;
switch_label ::= CASE expression DOISPONTOS | DEFAULT DOISPONTOS;
iteration_statement ::= while_statement| do_statement | for_statement | foreach_statement;
while_statement ::= WHILE LPAREN expression RPAREN embedded_statement;
do_statement ::= DO embedded_statement WHILE LPAREN expression RPAREN PONTOEVIRGULA;
for_statement ::= FOR:f LPAREN for_initializer PONTOEVIRGULA expression_opt:eo PONTOEVIRGULA statement_expression_list_opt RPAREN embedded_statement {: if (eo != null){ Verificador.verificarFor(eo.toString(), ((int) f)+1); } :};
for_initializer ::= | local_variable_declaration | statement_expression_list;
expression_opt ::= | expression:e {: RESULT = e; :};
statement_expression_list_opt ::= | statement_expression_list;
statement_expression_list ::= statement_expression | statement_expression statement_expression_list;
foreach_statement ::= FOREACH LPAREN type identifier IN expression RPAREN embedded_statement;
jump_statement ::= break_statement | continue_statement | goto_statement | return_statement | throw_statement;
break_statement ::= BREAK PONTOEVIRGULA;
continue_statement ::= CONTINUE PONTOEVIRGULA;
goto_statement ::= GOTO identifier PONTOEVIRGULA | GOTO CASE expression PONTOEVIRGULA | GOTO DEFAULT PONTOEVIRGULA;
return_statement ::= RETURN expression_opt PONTOEVIRGULA;
throw_statement ::= THROW expression_opt PONTOEVIRGULA;  
try_statement ::= TRY block catch_clauses finally_clause_opt | TRY block finally_clause;
finally_clause_opt ::= | finally_clause;
block ::= LCHAVE statement_aux RCHAVE;
catch_clauses ::=  specific_catch_clause_mais general_catch_clause_opt | specific_catch_clause_aux general_catch_clause;
specific_catch_clause_mais ::= specific_catch_clause | specific_catch_clause specific_catch_clause_mais;
specific_catch_clause_aux ::= | specific_catch_clause specific_catch_clause_aux;
general_catch_clause_opt ::= | general_catch_clause;
specific_catch_clause ::= CATCH LPAREN built_in_class_type identifier_opt RPAREN block | CATCH LPAREN qualified_identifier identifier_opt RPAREN block;
identifier_opt ::= | identifier;
general_catch_clause ::= CATCH block;
finally_clause ::= FINALLY block;
lock_statement ::= LOCK LPAREN expression RPAREN embedded_statement;
using_statement ::= USING LPAREN resource_acquisition RPAREN embedded_statement;
resource_acquisition ::=  local_variable_declaration | expression;


property_declaration ::= general_init_met_prop LCHAVE accessor_declarations RCHAVE;
property_modifier ::= | NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN;
accessor_declarations ::= get_accessor_declaration set_accessor_declaration_opt | set_accessor_declaration get_accessor_declaration_opt;
set_accessor_declaration_opt ::= | set_accessor_declaration;
get_accessor_declaration_opt ::= | get_accessor_declaration;
get_accessor_declaration ::= attributes GET maybe_empty_block;
set_accessor_declaration ::= attributes SET maybe_empty_block;


event_declaration ::= general_modifier EVENT type variable_declarator_aux PONTOEVIRGULA | attributes event_modifier EVENT type qualified_identifier LCHAVE event_accessor_declarations RCHAVE;
event_modifier ::= | NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN;
event_accessor_declarations ::= add_accessor_declaration remove_accessor_declaration | remove_accessor_declaration add_accessor_declaration;
add_accessor_declaration ::= attributes ADD block;
remove_accessor_declaration ::= attributes REMOVE block;

general_modifier ::= | modifier general_modifier;
modifier ::= NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | STATIC | VIRTUAL | SEALED | OVERRIDE | ABSTRACT | EXTERN | VOLATILE;
general_init ::= general_modifier type_or_void:t {: RESULT = t; :};
general_init_met_prop ::= general_init:t qualified_identifier:qi {: RESULT = new Variavel(qi.toString(), t.toString(), "variavel"); :};

/*class*/
class_declaration ::= attributes class_modifier CLASS identifier:i class_base_opt:cbo {: if (i != null){ if (cbo != null){ BlocoPrincipal.getInstance().iniciaBloco((i.toString()+";"), cbo.toString());}else{BlocoPrincipal.getInstance().iniciaBloco((i.toString()+";"));}} :} class_body ponto_virgula_opt;
class_base_opt ::= | class_base:cb {: RESULT = cb; :};
class_modifier ::= | NEW | PUBLIC | PROTECTED | INTERNAL | PRIVATE | ABSTRACT | SEALED;
class_base ::= DOISPONTOS qualified_identifier_list:qil {: RESULT = qil; :} | DOISPONTOS built_in_class_type qualified_identifier_list_opt;
qualified_identifier_list_opt ::= | VIRGULA qualified_identifier_list;
class_body ::= LCHAVE class_member_declaration_aux RCHAVE {: BlocoPrincipal.getInstance().finalizaBloco(); :};

class_member_declaration_aux ::= | class_member_declaration class_member_declaration_aux;
class_member_declaration ::= constant_declaration | field_declaration | method_declaration | type_declaration | constructor_declaration;

constructor_declaration ::= general_modifier constructor_declarator maybe_empty_block;
constructor_declarator ::= identifier LPAREN formal_parameter_list_aux RPAREN constructor_initializer_opt;
constructor_initializer_opt ::= | constructor_initializer;
constructor_initializer ::= DOISPONTOS BASE LPAREN argument_list RPAREN | DOISPONTOS THIS LPAREN argument_list RPAREN;
